# 扩展类型-接口

> TS的接口：用于约束类、对象、函数的标准

在约束对象的情况下, 接口和类型别名基本一样, 主要区别是在约束类上
```
// 约束对象 和 方法
interface User  {
    name: string
    age: number
    func: () => void
}
let user: User = {
    name: 'ljy',
    age: 18,
    func(){
        console.log(this.name);
    }
}

// 定义约束函数的接口
// 约束只有一个参数, 类型为number, 返回值为boolean 
interface User {
    (n: number): boolean
}

// 用类型别名约束函数
type User = (n: number) => boolean
// or
type User {
    (n: number): boolean
}
```

**接口可以继承**  
> 可以通过接口之间的继承,实现多种接口的组合

```
interface A {
    P1: string
}
interface B {
    p2: number
}
// 可以继承多个
interface C extends A, B {
    P3: boolean
}
```

使用类型别名也可以实现类似的效果, 叫做 **交叉类型**

```
type A = {
    P1: string
}
type B = {
    p2: number
}
// 交叉类型
type C = {
    P3: boolean
} & A & B
```

他们的区别:  
- 子接口不能覆盖父接口的成员
- 交叉类型会把相同成员的类型进行交叉

** 关键字readonly**

> 修饰目标是只读的

```
interface User {
    readonly id: string
    name: string
    readonly arr: readonly string[]
}

const arr: readonly number[] = [3, 4, 6];
arr[0] = 1; // ts报错
```